{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initialize Next.js 14 Project with TypeScript",
        "description": "Set up a new Next.js 14 project with TypeScript, Tailwind CSS, and other required dependencies for the vacant shop map application.",
        "details": "1. Create a new Next.js project using the App Router: `npx create-next-app@latest vacant-shop-map --typescript --tailwind --eslint`\n2. Configure TypeScript settings in tsconfig.json\n3. Set up project structure with appropriate folders:\n   - app/ (for App Router pages)\n   - components/ (for UI components)\n   - lib/ (for utilities)\n   - types/ (for TypeScript interfaces)\n   - public/ (for static assets)\n4. Install additional dependencies:\n   - Zustand for state management: `npm install zustand`\n   - Axios for HTTP requests: `npm install axios`\n   - Headless UI: `npm install @headlessui/react`\n   - Framer Motion: `npm install framer-motion`\n5. Configure environment variables (.env.local) for API keys and endpoints",
        "testStrategy": "1. Verify project builds without errors: `npm run build`\n2. Ensure development server runs correctly: `npm run dev`\n3. Confirm TypeScript configuration is working by testing type checking\n4. Validate that all installed packages are working by importing and using a simple component from each",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Create Basic Layout and Responsive Design",
        "description": "Implement the basic layout structure for the application with responsive design for mobile devices, focusing on a mobile-first approach.",
        "details": "1. Create a root layout component in app/layout.tsx with appropriate metadata\n2. Implement responsive viewport settings for mobile optimization\n3. Create a basic header component with minimal UI elements\n4. Set up Tailwind CSS configuration for custom theme:\n   - Define color palette based on brand guidelines\n   - Configure breakpoints focusing on mobile sizes (320px minimum)\n   - Set up typography scale\n5. Create responsive container components that adapt to different screen sizes\n6. Implement basic loading and error states\n7. Ensure touch-friendly UI elements with appropriate sizing (min 44px touch targets)",
        "testStrategy": "1. Test layout on multiple device sizes using browser dev tools\n2. Verify responsiveness on small screens (320px - iPhone SE)\n3. Test on medium screens (375px-414px - standard mobile)\n4. Validate touch target sizes meet accessibility standards\n5. Run Lighthouse accessibility tests to ensure basic compliance",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Integrate Map API and Display Basic Map",
        "description": "Integrate either Google Maps or Naver Maps API and implement the basic map display that takes up the full screen of the application.",
        "details": "1. Decide between Google Maps or Naver Maps based on project requirements\n2. Register for API key from the chosen map provider\n3. Create a Map component:\n   ```tsx\n   // components/Map/MapContainer.tsx\n   import { useEffect, useRef } from 'react';\n   import { useMapStore } from '@/store/mapStore';\n   \n   export default function MapContainer() {\n     const mapRef = useRef<HTMLDivElement>(null);\n     const { setMapInstance } = useMapStore();\n     \n     useEffect(() => {\n       if (!mapRef.current) return;\n       \n       // Initialize map (Google Maps example)\n       const map = new google.maps.Map(mapRef.current, {\n         center: { lat: 37.5665, lng: 126.9780 }, // Seoul coordinates\n         zoom: 14,\n         disableDefaultUI: true, // Minimize UI for mobile\n         zoomControl: true,\n         gestureHandling: 'greedy', // For better mobile interaction\n       });\n       \n       setMapInstance(map);\n       \n       return () => {\n         // Cleanup if needed\n       };\n     }, [setMapInstance]);\n     \n     return <div ref={mapRef} className=\"w-full h-screen\" />;\n   }\n   ```\n4. Create a map store using Zustand:\n   ```tsx\n   // store/mapStore.ts\n   import { create } from 'zustand';\n   \n   interface MapState {\n     mapInstance: google.maps.Map | null;\n     setMapInstance: (map: google.maps.Map) => void;\n   }\n   \n   export const useMapStore = create<MapState>((set) => ({\n     mapInstance: null,\n     setMapInstance: (map) => set({ mapInstance: map }),\n   }));\n   ```\n5. Add map script loading in the document head\n6. Implement basic map controls (zoom, pan)\n7. Optimize map for mobile touch gestures",
        "testStrategy": "1. Verify map loads correctly on the page\n2. Test map interactions (zoom, pan) on mobile devices\n3. Verify map takes up full screen as required\n4. Test performance metrics for initial map loading\n5. Validate map renders correctly across different mobile browsers\n6. Check API usage to ensure it's within limits",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Define Data Models and Type Interfaces",
        "description": "Create TypeScript interfaces for all data models required by the application, including VacantShop and MapFilter as specified in the PRD.",
        "details": "1. Create a types directory to house all TypeScript interfaces\n2. Implement the VacantShop interface as specified in the PRD:\n   ```typescript\n   // types/VacantShop.ts\n   export interface VacantShop {\n     id: string;\n     name: string;\n     address: string;\n     latitude: number;\n     longitude: number;\n     area: number; // 면적 (평)\n     monthlyRent: number; // 월 임대료\n     deposit: number; // 보증금\n     shopType: 'restaurant' | 'retail' | 'office' | 'etc';\n     images: string[];\n     contact: {\n       phone: string;\n       email?: string;\n     };\n     description: string;\n     createdAt: Date;\n     updatedAt: Date;\n   }\n   ```\n3. Implement the MapFilter interface:\n   ```typescript\n   // types/MapFilter.ts\n   export interface MapFilter {\n     rentRange: [number, number];\n     areaRange: [number, number];\n     shopTypes: string[];\n     region?: string;\n   }\n   ```\n4. Create additional helper types and interfaces as needed:\n   ```typescript\n   // types/Map.ts\n   export interface MapMarker {\n     id: string;\n     position: {\n       lat: number;\n       lng: number;\n     };\n     shopType: string;\n     isActive: boolean;\n   }\n   \n   // types/BottomSheet.ts\n   export interface BottomSheetState {\n     isOpen: boolean;\n     shopId: string | null;\n     height: 'collapsed' | 'partial' | 'full';\n   }\n   ```",
        "testStrategy": "1. Validate interfaces against sample data to ensure all required fields are present\n2. Use TypeScript compiler to verify type correctness\n3. Create test utilities that use these interfaces to confirm they work as expected\n4. Review interfaces with team to ensure they meet all requirements",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement API Service Layer",
        "description": "Create a service layer to handle API requests for vacant shop data, implementing proper error handling and response parsing.",
        "details": "1. Set up Axios instance with base configuration:\n   ```typescript\n   // lib/api/axios.ts\n   import axios from 'axios';\n   \n   const apiClient = axios.create({\n     baseURL: process.env.NEXT_PUBLIC_API_URL,\n     headers: {\n       'Content-Type': 'application/json',\n     },\n     timeout: 10000,\n   });\n   \n   export default apiClient;\n   ```\n2. Create API service for vacant shops:\n   ```typescript\n   // lib/api/vacantShopService.ts\n   import { VacantShop, MapFilter } from '@/types';\n   import apiClient from './axios';\n   \n   export const vacantShopService = {\n     async getShops(filter?: Partial<MapFilter>): Promise<VacantShop[]> {\n       try {\n         const params = filter ? { ...filter } : {};\n         const response = await apiClient.get('/shops', { params });\n         return response.data;\n       } catch (error) {\n         console.error('Error fetching shops:', error);\n         throw error;\n       }\n     },\n     \n     async getShopById(id: string): Promise<VacantShop> {\n       try {\n         const response = await apiClient.get(`/shops/${id}`);\n         return response.data;\n       } catch (error) {\n         console.error(`Error fetching shop ${id}:`, error);\n         throw error;\n       }\n     },\n     \n     // Additional methods as needed\n   };\n   ```\n3. Implement mock data for development:\n   ```typescript\n   // lib/mockData.ts\n   import { VacantShop } from '@/types';\n   \n   export const mockShops: VacantShop[] = [\n     // Add 10-15 sample shops with realistic data\n   ];\n   ```\n4. Create API response interceptors for error handling\n5. Implement caching strategy for API responses to minimize API calls",
        "testStrategy": "1. Unit test each API service function\n2. Test error handling with mocked failed responses\n3. Verify correct parsing of API responses\n4. Test with mock data to ensure compatibility with interfaces\n5. Measure and optimize API call performance",
        "priority": "high",
        "dependencies": [
          1,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Custom Markers for Vacant Shops",
        "description": "Create a system for displaying custom markers on the map for vacant shops, with different icons based on shop type.",
        "details": "1. Design or source marker icons for different shop types (restaurant, retail, office, etc.)\n2. Create a MarkerManager component:\n   ```tsx\n   // components/Map/MarkerManager.tsx\n   import { useEffect } from 'react';\n   import { useMapStore } from '@/store/mapStore';\n   import { VacantShop } from '@/types';\n   \n   interface MarkerManagerProps {\n     shops: VacantShop[];\n     onMarkerClick: (shopId: string) => void;\n   }\n   \n   export default function MarkerManager({ shops, onMarkerClick }: MarkerManagerProps) {\n     const { mapInstance } = useMapStore();\n     \n     useEffect(() => {\n       if (!mapInstance || !shops.length) return;\n       \n       const markers = shops.map(shop => {\n         const marker = new google.maps.Marker({\n           position: { lat: shop.latitude, lng: shop.longitude },\n           map: mapInstance,\n           icon: getMarkerIconByType(shop.shopType),\n           title: shop.name,\n         });\n         \n         marker.addListener('click', () => {\n           onMarkerClick(shop.id);\n         });\n         \n         return marker;\n       });\n       \n       return () => {\n         markers.forEach(marker => marker.setMap(null));\n       };\n     }, [mapInstance, shops, onMarkerClick]);\n     \n     return null; // This is a controller component, no UI\n   }\n   \n   function getMarkerIconByType(type: string) {\n     switch(type) {\n       case 'restaurant':\n         return '/markers/restaurant.svg';\n       case 'retail':\n         return '/markers/retail.svg';\n       case 'office':\n         return '/markers/office.svg';\n       default:\n         return '/markers/default.svg';\n     }\n   }\n   ```\n3. Implement marker hover/touch preview functionality\n4. Create store for tracking active/selected markers\n5. Optimize marker rendering for performance",
        "testStrategy": "1. Test marker rendering with different data sets\n2. Verify markers appear at correct coordinates\n3. Test marker click events trigger the correct callbacks\n4. Validate different marker icons display correctly based on shop type\n5. Performance test with a large number of markers\n6. Test marker hover/touch preview functionality on mobile devices",
        "priority": "high",
        "dependencies": [
          3,
          4,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Implement Marker Clustering",
        "description": "Add marker clustering functionality to improve performance and usability when many markers are displayed in a concentrated area.",
        "details": "1. Install a clustering library compatible with the chosen map API (e.g., @googlemaps/markerclusterer for Google Maps)\n2. Extend the MarkerManager component to support clustering:\n   ```tsx\n   // components/Map/MarkerManager.tsx (extended)\n   import { MarkerClusterer } from '@googlemaps/markerclusterer';\n   \n   // Inside the useEffect where markers are created:\n   const markers = shops.map(shop => {\n     // Create markers as before\n   });\n   \n   // Create a clusterer with custom styling\n   const clusterer = new MarkerClusterer({\n     map: mapInstance,\n     markers: markers,\n     renderer: {\n       render: ({ count, position }) => {\n         // Custom cluster renderer\n         const marker = new google.maps.Marker({\n           position,\n           icon: {\n             path: google.maps.SymbolPath.CIRCLE,\n             fillColor: '#4285F4',\n             fillOpacity: 0.8,\n             strokeWeight: 1,\n             strokeColor: '#FFFFFF',\n             scale: Math.min(count, 40) + 10,\n           },\n           label: {\n             text: String(count),\n             color: 'white',\n             fontSize: '12px',\n           },\n           zIndex: Number(google.maps.Marker.MAX_ZINDEX) + count,\n         });\n         return marker;\n       },\n     },\n   });\n   \n   return () => {\n     clusterer.clearMarkers();\n     markers.forEach(marker => marker.setMap(null));\n   };\n   ```\n3. Configure clustering thresholds and distances appropriate for mobile view\n4. Implement custom cluster styling to match application design\n5. Optimize cluster rendering for performance",
        "testStrategy": "1. Test clustering with various marker densities\n2. Verify clusters correctly combine and separate when zooming\n3. Test cluster click behavior expands appropriately\n4. Performance test with large datasets (100+ markers)\n5. Verify custom styling is applied correctly\n6. Test on various mobile screen sizes to ensure usability",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create Bottom Sheet Component",
        "description": "Implement a draggable bottom sheet component that slides up from the bottom of the screen to display vacant shop details when a marker is clicked.",
        "details": "1. Create a reusable BottomSheet component using Framer Motion for animations:\n   ```tsx\n   // components/BottomSheet/BottomSheet.tsx\n   import { useRef, useEffect } from 'react';\n   import { motion, PanInfo, useAnimation } from 'framer-motion';\n   \n   interface BottomSheetProps {\n     isOpen: boolean;\n     onClose: () => void;\n     children: React.ReactNode;\n     snapPoints?: {\n       collapsed: number;\n       partial: number;\n       full: number;\n     };\n   }\n   \n   export default function BottomSheet({\n     isOpen,\n     onClose,\n     children,\n     snapPoints = { collapsed: 0, partial: 300, full: 600 }\n   }: BottomSheetProps) {\n     const controls = useAnimation();\n     const sheetRef = useRef<HTMLDivElement>(null);\n     \n     useEffect(() => {\n       if (isOpen) {\n         controls.start({ y: snapPoints.partial });\n       } else {\n         controls.start({ y: snapPoints.collapsed });\n       }\n     }, [isOpen, controls, snapPoints]);\n     \n     const handleDragEnd = (_: any, info: PanInfo) => {\n       const offset = info.offset.y;\n       const velocity = info.velocity.y;\n       \n       if (offset > 100 || velocity > 500) {\n         onClose();\n       } else if (offset < -100 || velocity < -500) {\n         controls.start({ y: snapPoints.full });\n       } else {\n         controls.start({ y: snapPoints.partial });\n       }\n     };\n     \n     const handleBackdropClick = () => {\n       onClose();\n     };\n     \n     if (!isOpen) return null;\n     \n     return (\n       <>\n         <div \n           className=\"fixed inset-0 bg-black bg-opacity-50 z-40\"\n           onClick={handleBackdropClick}\n         />\n         <motion.div\n           ref={sheetRef}\n           className=\"fixed bottom-0 left-0 right-0 bg-white rounded-t-2xl z-50 overflow-hidden\"\n           initial={{ y: '100%' }}\n           animate={controls}\n           drag=\"y\"\n           dragConstraints={{ top: 0, bottom: 0 }}\n           dragElastic={0.2}\n           onDragEnd={handleDragEnd}\n         >\n           <div className=\"w-12 h-1.5 bg-gray-300 rounded-full mx-auto my-3\" />\n           <div className=\"px-4 pb-8 max-h-[calc(100vh-40px)] overflow-y-auto\">\n             {children}\n           </div>\n         </motion.div>\n       </>\n     );\n   }\n   ```\n2. Create a store for managing bottom sheet state:\n   ```typescript\n   // store/bottomSheetStore.ts\n   import { create } from 'zustand';\n   import { BottomSheetState } from '@/types';\n   \n   interface BottomSheetStore extends BottomSheetState {\n     openSheet: (shopId: string) => void;\n     closeSheet: () => void;\n     setHeight: (height: 'collapsed' | 'partial' | 'full') => void;\n   }\n   \n   export const useBottomSheetStore = create<BottomSheetStore>((set) => ({\n     isOpen: false,\n     shopId: null,\n     height: 'partial',\n     openSheet: (shopId) => set({ isOpen: true, shopId }),\n     closeSheet: () => set({ isOpen: false, shopId: null }),\n     setHeight: (height) => set({ height }),\n   }));\n   ```\n3. Implement touch gesture handling for dragging\n4. Add snap points for different sheet heights (collapsed, partial, full)\n5. Create backdrop overlay that closes sheet when tapped",
        "testStrategy": "1. Test bottom sheet opening and closing animations\n2. Verify drag gestures work correctly on mobile devices\n3. Test snap points functionality (partial and full views)\n4. Verify backdrop click closes the sheet\n5. Test sheet behavior with different content heights\n6. Validate accessibility for keyboard and screen reader users",
        "priority": "high",
        "dependencies": [
          2,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Shop Detail View in Bottom Sheet",
        "description": "Create the detailed view of vacant shop information to be displayed in the bottom sheet, including basic info, image gallery, and contact information.",
        "details": "1. Create ShopDetail component to display in the bottom sheet:\n   ```tsx\n   // components/Shop/ShopDetail.tsx\n   import { useState, useEffect } from 'react';\n   import Image from 'next/image';\n   import { VacantShop } from '@/types';\n   import { vacantShopService } from '@/lib/api/vacantShopService';\n   import ImageGallery from './ImageGallery';\n   \n   interface ShopDetailProps {\n     shopId: string;\n   }\n   \n   export default function ShopDetail({ shopId }: ShopDetailProps) {\n     const [shop, setShop] = useState<VacantShop | null>(null);\n     const [loading, setLoading] = useState(true);\n     const [error, setError] = useState<string | null>(null);\n     \n     useEffect(() => {\n       async function fetchShopDetail() {\n         try {\n           setLoading(true);\n           const data = await vacantShopService.getShopById(shopId);\n           setShop(data);\n           setError(null);\n         } catch (err) {\n           setError('Failed to load shop details');\n         } finally {\n           setLoading(false);\n         }\n       }\n       \n       if (shopId) {\n         fetchShopDetail();\n       }\n     }, [shopId]);\n     \n     if (loading) return <div className=\"p-4 text-center\">Loading...</div>;\n     if (error) return <div className=\"p-4 text-red-500\">{error}</div>;\n     if (!shop) return <div className=\"p-4 text-center\">No shop data found</div>;\n     \n     return (\n       <div className=\"space-y-4\">\n         <h2 className=\"text-xl font-bold\">{shop.name}</h2>\n         \n         <ImageGallery images={shop.images} />\n         \n         <div className=\"space-y-2\">\n           <div className=\"flex justify-between\">\n             <span className=\"text-gray-500\">주소</span>\n             <span>{shop.address}</span>\n           </div>\n           <div className=\"flex justify-between\">\n             <span className=\"text-gray-500\">면적</span>\n             <span>{shop.area} 평</span>\n           </div>\n           <div className=\"flex justify-between\">\n             <span className=\"text-gray-500\">월 임대료</span>\n             <span>{shop.monthlyRent.toLocaleString()}원</span>\n           </div>\n           <div className=\"flex justify-between\">\n             <span className=\"text-gray-500\">보증금</span>\n             <span>{shop.deposit.toLocaleString()}원</span>\n           </div>\n           <div className=\"flex justify-between\">\n             <span className=\"text-gray-500\">업종</span>\n             <span>{getShopTypeLabel(shop.shopType)}</span>\n           </div>\n         </div>\n         \n         <div className=\"border-t pt-4\">\n           <h3 className=\"font-semibold mb-2\">상세 설명</h3>\n           <p className=\"text-gray-700\">{shop.description}</p>\n         </div>\n         \n         <div className=\"border-t pt-4\">\n           <h3 className=\"font-semibold mb-2\">연락처</h3>\n           <div className=\"flex items-center justify-between\">\n             <span>{shop.contact.phone}</span>\n             <button className=\"bg-blue-500 text-white px-4 py-2 rounded-lg\">\n               연락하기\n             </button>\n           </div>\n           {shop.contact.email && (\n             <div className=\"mt-2 text-gray-600\">{shop.contact.email}</div>\n           )}\n         </div>\n       </div>\n     );\n   }\n   \n   function getShopTypeLabel(type: string): string {\n     switch(type) {\n       case 'restaurant': return '음식점';\n       case 'retail': return '소매';\n       case 'office': return '사무실';\n       default: return '기타';\n     }\n   }\n   ```\n2. Create ImageGallery component for shop images:\n   ```tsx\n   // components/Shop/ImageGallery.tsx\n   import { useState } from 'react';\n   import Image from 'next/image';\n   \n   interface ImageGalleryProps {\n     images: string[];\n   }\n   \n   export default function ImageGallery({ images }: ImageGalleryProps) {\n     const [activeIndex, setActiveIndex] = useState(0);\n     \n     if (!images.length) {\n       return (\n         <div className=\"h-48 bg-gray-200 flex items-center justify-center rounded-lg\">\n           <span className=\"text-gray-500\">No images available</span>\n         </div>\n       );\n     }\n     \n     return (\n       <div className=\"space-y-2\">\n         <div className=\"relative h-48 rounded-lg overflow-hidden\">\n           <Image \n             src={images[activeIndex]}\n             alt=\"Shop image\"\n             fill\n             className=\"object-cover\"\n           />\n         </div>\n         \n         {images.length > 1 && (\n           <div className=\"flex space-x-2 overflow-x-auto py-2\">\n             {images.map((image, index) => (\n               <div \n                 key={index}\n                 className={`relative w-16 h-16 rounded-md overflow-hidden cursor-pointer ${index === activeIndex ? 'ring-2 ring-blue-500' : ''}`}\n                 onClick={() => setActiveIndex(index)}\n               >\n                 <Image \n                   src={image}\n                   alt={`Thumbnail ${index + 1}`}\n                   fill\n                   className=\"object-cover\"\n                 />\n               </div>\n             ))}\n           </div>\n         )}\n       </div>\n     );\n   }\n   ```\n3. Integrate with bottom sheet component\n4. Add loading states and error handling\n5. Implement contact functionality",
        "testStrategy": "1. Test shop detail loading with various shop data\n2. Verify image gallery works correctly with different numbers of images\n3. Test loading and error states\n4. Verify all shop information displays correctly\n5. Test contact button functionality\n6. Validate responsive layout on different mobile screen sizes",
        "priority": "high",
        "dependencies": [
          5,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement Map and Marker Integration",
        "description": "Connect the map, markers, and bottom sheet components to create a cohesive user experience where clicking a marker opens the bottom sheet with shop details.",
        "details": "1. Create a main page component that integrates all elements:\n   ```tsx\n   // app/page.tsx\n   'use client';\n   \n   import { useEffect, useState } from 'react';\n   import MapContainer from '@/components/Map/MapContainer';\n   import MarkerManager from '@/components/Map/MarkerManager';\n   import BottomSheet from '@/components/BottomSheet/BottomSheet';\n   import ShopDetail from '@/components/Shop/ShopDetail';\n   import { useBottomSheetStore } from '@/store/bottomSheetStore';\n   import { vacantShopService } from '@/lib/api/vacantShopService';\n   import { VacantShop } from '@/types';\n   \n   export default function HomePage() {\n     const [shops, setShops] = useState<VacantShop[]>([]);\n     const [loading, setLoading] = useState(true);\n     const { isOpen, shopId, openSheet, closeSheet } = useBottomSheetStore();\n     \n     useEffect(() => {\n       async function fetchShops() {\n         try {\n           setLoading(true);\n           const data = await vacantShopService.getShops();\n           setShops(data);\n         } catch (error) {\n           console.error('Failed to fetch shops:', error);\n         } finally {\n           setLoading(false);\n         }\n       }\n       \n       fetchShops();\n     }, []);\n     \n     const handleMarkerClick = (id: string) => {\n       openSheet(id);\n     };\n     \n     return (\n       <main className=\"relative h-screen w-full overflow-hidden\">\n         <MapContainer />\n         {!loading && (\n           <MarkerManager \n             shops={shops} \n             onMarkerClick={handleMarkerClick} \n           />\n         )}\n         \n         <BottomSheet \n           isOpen={isOpen} \n           onClose={closeSheet}\n         >\n           {shopId && <ShopDetail shopId={shopId} />}\n         </BottomSheet>\n       </main>\n     );\n   }\n   ```\n2. Implement marker click handler to open bottom sheet\n3. Ensure map is visible behind the bottom sheet\n4. Add visual feedback for selected marker\n5. Implement smooth transitions between states",
        "testStrategy": "1. Test the full user flow from map view to marker click to bottom sheet display\n2. Verify selected marker is visually highlighted\n3. Test closing the bottom sheet returns to the map view correctly\n4. Validate the integration works on various mobile devices\n5. Test performance of the integrated components\n6. Verify error states are handled gracefully",
        "priority": "high",
        "dependencies": [
          3,
          6,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Create Filter UI Components",
        "description": "Develop the UI components for filtering vacant shops by rent range, area, shop type, and region.",
        "details": "1. Create a FilterPanel component:\n   ```tsx\n   // components/Filter/FilterPanel.tsx\n   import { useState } from 'react';\n   import { MapFilter } from '@/types';\n   import RangeSlider from './RangeSlider';\n   import ShopTypeSelector from './ShopTypeSelector';\n   import RegionSearch from './RegionSearch';\n   \n   interface FilterPanelProps {\n     initialFilters: MapFilter;\n     onApplyFilters: (filters: MapFilter) => void;\n     onClose: () => void;\n   }\n   \n   export default function FilterPanel({\n     initialFilters,\n     onApplyFilters,\n     onClose\n   }: FilterPanelProps) {\n     const [filters, setFilters] = useState<MapFilter>(initialFilters);\n     \n     const handleRentChange = (range: [number, number]) => {\n       setFilters(prev => ({ ...prev, rentRange: range }));\n     };\n     \n     const handleAreaChange = (range: [number, number]) => {\n       setFilters(prev => ({ ...prev, areaRange: range }));\n     };\n     \n     const handleShopTypesChange = (types: string[]) => {\n       setFilters(prev => ({ ...prev, shopTypes: types }));\n     };\n     \n     const handleRegionChange = (region: string) => {\n       setFilters(prev => ({ ...prev, region }));\n     };\n     \n     const handleApply = () => {\n       onApplyFilters(filters);\n       onClose();\n     };\n     \n     const handleReset = () => {\n       const defaultFilters: MapFilter = {\n         rentRange: [0, 1000000],\n         areaRange: [0, 100],\n         shopTypes: [],\n         region: undefined\n       };\n       setFilters(defaultFilters);\n     };\n     \n     return (\n       <div className=\"bg-white p-4 rounded-lg space-y-6\">\n         <div className=\"flex justify-between items-center\">\n           <h2 className=\"text-lg font-semibold\">필터</h2>\n           <button onClick={onClose} className=\"text-gray-500\">\n             <span className=\"sr-only\">닫기</span>\n             <svg className=\"w-5 h-5\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n               <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M6 18L18 6M6 6l12 12\" />\n             </svg>\n           </button>\n         </div>\n         \n         <div className=\"space-y-4\">\n           <div>\n             <h3 className=\"font-medium mb-2\">월 임대료 범위</h3>\n             <RangeSlider \n               min={0}\n               max={1000000}\n               step={10000}\n               value={filters.rentRange}\n               onChange={handleRentChange}\n               formatValue={value => `${value.toLocaleString()}원`}\n             />\n           </div>\n           \n           <div>\n             <h3 className=\"font-medium mb-2\">면적 범위</h3>\n             <RangeSlider \n               min={0}\n               max={100}\n               step={1}\n               value={filters.areaRange}\n               onChange={handleAreaChange}\n               formatValue={value => `${value}평`}\n             />\n           </div>\n           \n           <div>\n             <h3 className=\"font-medium mb-2\">상가 유형</h3>\n             <ShopTypeSelector \n               selected={filters.shopTypes}\n               onChange={handleShopTypesChange}\n             />\n           </div>\n           \n           <div>\n             <h3 className=\"font-medium mb-2\">지역 검색</h3>\n             <RegionSearch \n               value={filters.region}\n               onChange={handleRegionChange}\n             />\n           </div>\n         </div>\n         \n         <div className=\"flex space-x-2 pt-2\">\n           <button \n             onClick={handleReset}\n             className=\"flex-1 py-2 border border-gray-300 rounded-lg text-gray-700\"\n           >\n             초기화\n           </button>\n           <button \n             onClick={handleApply}\n             className=\"flex-1 py-2 bg-blue-500 text-white rounded-lg\"\n           >\n             적용하기\n           </button>\n         </div>\n       </div>\n     );\n   }\n   ```\n2. Create supporting components (RangeSlider, ShopTypeSelector, RegionSearch)\n3. Implement a filter button in the map UI\n4. Create a modal or slide-in panel to contain the filter UI\n5. Design mobile-friendly input controls",
        "testStrategy": "1. Test each filter component individually\n2. Verify range sliders work correctly on touch devices\n3. Test filter panel opening and closing\n4. Validate filter reset functionality\n5. Test filter application updates the map correctly\n6. Verify UI is responsive and usable on small screens",
        "priority": "medium",
        "dependencies": [
          2,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Implement Filter Logic and Integration",
        "description": "Connect the filter UI with the map and markers to enable real-time filtering of vacant shops based on user criteria.",
        "details": "1. Create a filter store using Zustand:\n   ```typescript\n   // store/filterStore.ts\n   import { create } from 'zustand';\n   import { MapFilter } from '@/types';\n   \n   interface FilterState {\n     filters: MapFilter;\n     isFilterPanelOpen: boolean;\n     setFilters: (filters: MapFilter) => void;\n     openFilterPanel: () => void;\n     closeFilterPanel: () => void;\n     resetFilters: () => void;\n   }\n   \n   const DEFAULT_FILTERS: MapFilter = {\n     rentRange: [0, 1000000],\n     areaRange: [0, 100],\n     shopTypes: [],\n     region: undefined\n   };\n   \n   export const useFilterStore = create<FilterState>((set) => ({\n     filters: DEFAULT_FILTERS,\n     isFilterPanelOpen: false,\n     setFilters: (filters) => set({ filters }),\n     openFilterPanel: () => set({ isFilterPanelOpen: true }),\n     closeFilterPanel: () => set({ isFilterPanelOpen: false }),\n     resetFilters: () => set({ filters: DEFAULT_FILTERS }),\n   }));\n   ```\n2. Modify the vacantShopService to support filtering:\n   ```typescript\n   // Extended vacantShopService.ts\n   async getShops(filter?: Partial<MapFilter>): Promise<VacantShop[]> {\n     try {\n       // In a real app, these would be API query parameters\n       const params = filter ? {\n         minRent: filter.rentRange?.[0],\n         maxRent: filter.rentRange?.[1],\n         minArea: filter.areaRange?.[0],\n         maxArea: filter.areaRange?.[1],\n         shopTypes: filter.shopTypes?.join(','),\n         region: filter.region\n       } : {};\n       \n       const response = await apiClient.get('/shops', { params });\n       return response.data;\n     } catch (error) {\n       console.error('Error fetching shops:', error);\n       throw error;\n     }\n   }\n   ```\n3. Update the main page to include filter functionality:\n   ```tsx\n   // Extended HomePage component\n   import FilterButton from '@/components/Filter/FilterButton';\n   import FilterPanel from '@/components/Filter/FilterPanel';\n   import { useFilterStore } from '@/store/filterStore';\n   \n   // Inside the HomePage component\n   const { filters, isFilterPanelOpen, setFilters, openFilterPanel, closeFilterPanel } = useFilterStore();\n   \n   useEffect(() => {\n     async function fetchShops() {\n       try {\n         setLoading(true);\n         const data = await vacantShopService.getShops(filters);\n         setShops(data);\n       } catch (error) {\n         console.error('Failed to fetch shops:', error);\n       } finally {\n         setLoading(false);\n       }\n     }\n     \n     fetchShops();\n   }, [filters]);\n   \n   // Add to the JSX\n   <FilterButton onClick={openFilterPanel} />\n   \n   {isFilterPanelOpen && (\n     <div className=\"absolute inset-0 bg-black bg-opacity-50 z-30 flex items-center justify-center p-4\">\n       <FilterPanel \n         initialFilters={filters}\n         onApplyFilters={setFilters}\n         onClose={closeFilterPanel}\n       />\n     </div>\n   )}\n   ```\n4. Implement real-time marker updates when filters change\n5. Add loading indicators during filter application\n6. Optimize filter performance for mobile devices",
        "testStrategy": "1. Test filter application with various combinations of criteria\n2. Verify markers update correctly when filters change\n3. Test edge cases (no results, max/min values)\n4. Validate performance with large datasets\n5. Test filter panel UI on different mobile devices\n6. Verify filter state persists correctly during app usage",
        "priority": "medium",
        "dependencies": [
          6,
          11
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement Geolocation and Current Location",
        "description": "Add functionality to detect the user's current location and center the map on it, with appropriate permission handling.",
        "details": "1. Create a geolocation utility:\n   ```typescript\n   // lib/geolocation.ts\n   export async function getCurrentPosition(): Promise<GeolocationPosition> {\n     return new Promise((resolve, reject) => {\n       if (!navigator.geolocation) {\n         reject(new Error('Geolocation is not supported by your browser'));\n         return;\n       }\n       \n       navigator.geolocation.getCurrentPosition(resolve, reject, {\n         enableHighAccuracy: true,\n         timeout: 5000,\n         maximumAge: 0\n       });\n     });\n   }\n   ```\n2. Create a CurrentLocationButton component:\n   ```tsx\n   // components/Map/CurrentLocationButton.tsx\n   import { useState } from 'react';\n   import { useMapStore } from '@/store/mapStore';\n   import { getCurrentPosition } from '@/lib/geolocation';\n   \n   export default function CurrentLocationButton() {\n     const [loading, setLoading] = useState(false);\n     const [error, setError] = useState<string | null>(null);\n     const { mapInstance } = useMapStore();\n     \n     const handleClick = async () => {\n       if (!mapInstance) return;\n       \n       try {\n         setLoading(true);\n         setError(null);\n         \n         const position = await getCurrentPosition();\n         const { latitude, longitude } = position.coords;\n         \n         mapInstance.panTo({ lat: latitude, lng: longitude });\n         mapInstance.setZoom(16); // Zoom in to show nearby shops\n       } catch (err) {\n         console.error('Error getting current location:', err);\n         setError('위치 정보를 가져올 수 없습니다.');\n       } finally {\n         setLoading(false);\n       }\n     };\n     \n     return (\n       <div className=\"absolute bottom-24 right-4 z-10\">\n         <button\n           onClick={handleClick}\n           disabled={loading}\n           className=\"bg-white p-3 rounded-full shadow-lg\"\n           aria-label=\"현재 위치로 이동\"\n         >\n           {loading ? (\n             <svg className=\"animate-spin h-6 w-6 text-blue-500\" xmlns=\"http://www.w3.org/2000/svg\" fill=\"none\" viewBox=\"0 0 24 24\">\n               <circle className=\"opacity-25\" cx=\"12\" cy=\"12\" r=\"10\" stroke=\"currentColor\" strokeWidth=\"4\"></circle>\n               <path className=\"opacity-75\" fill=\"currentColor\" d=\"M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z\"></path>\n             </svg>\n           ) : (\n             <svg className=\"h-6 w-6 text-blue-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n               <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z\" />\n               <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M15 11a3 3 0 11-6 0 3 3 0 016 0z\" />\n             </svg>\n           )}\n         </button>\n         {error && (\n           <div className=\"mt-2 bg-red-100 text-red-800 text-sm p-2 rounded-md\">\n             {error}\n           </div>\n         )}\n       </div>\n     );\n   }\n   ```\n3. Add initial location detection on app load\n4. Implement permission handling and error states\n5. Add visual feedback for location detection process",
        "testStrategy": "1. Test geolocation permission flows (allow, deny, ignore)\n2. Verify map centers correctly on user location\n3. Test error handling for various geolocation errors\n4. Validate loading states display correctly\n5. Test on real mobile devices with GPS\n6. Verify behavior when location services are disabled",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Implement Performance Optimizations",
        "description": "Optimize the application for mobile performance, focusing on load times, rendering efficiency, and smooth interactions.",
        "details": "1. Implement code splitting and lazy loading:\n   ```tsx\n   // Lazy load components that aren't needed immediately\n   import dynamic from 'next/dynamic';\n   \n   const FilterPanel = dynamic(() => import('@/components/Filter/FilterPanel'), {\n     loading: () => <div className=\"p-4\">Loading filters...</div>,\n   });\n   \n   const ShopDetail = dynamic(() => import('@/components/Shop/ShopDetail'), {\n     loading: () => <div className=\"p-4\">Loading details...</div>,\n   });\n   ```\n2. Implement image optimization:\n   ```tsx\n   // Optimize images using Next.js Image component\n   import Image from 'next/image';\n   \n   // In ImageGallery component\n   <Image \n     src={image}\n     alt=\"Shop image\"\n     width={400}\n     height={300}\n     placeholder=\"blur\"\n     blurDataURL=\"data:image/png;base64,...\"\n     className=\"object-cover rounded-lg\"\n   />\n   ```\n3. Implement data caching:\n   ```typescript\n   // lib/api/vacantShopService.ts\n   // Simple in-memory cache\n   const cache: Record<string, { data: any; timestamp: number }> = {};\n   const CACHE_TTL = 5 * 60 * 1000; // 5 minutes\n   \n   async function cachedFetch(url: string, params?: any) {\n     const queryString = params ? new URLSearchParams(params).toString() : '';\n     const cacheKey = `${url}?${queryString}`;\n     \n     const now = Date.now();\n     const cachedItem = cache[cacheKey];\n     \n     if (cachedItem && now - cachedItem.timestamp < CACHE_TTL) {\n       return cachedItem.data;\n     }\n     \n     const response = await apiClient.get(url, { params });\n     cache[cacheKey] = {\n       data: response.data,\n       timestamp: now\n     };\n     \n     return response.data;\n   }\n   ```\n4. Implement virtualized rendering for large lists\n5. Add debouncing for map interactions\n6. Optimize marker rendering with visibility checks\n7. Implement progressive loading strategies",
        "testStrategy": "1. Measure and compare load times before and after optimizations\n2. Test performance on low-end mobile devices\n3. Use Lighthouse to measure performance metrics\n4. Test with slow network conditions\n5. Verify memory usage remains stable during extended use\n6. Validate that optimizations don't break functionality",
        "priority": "medium",
        "dependencies": [
          3,
          6,
          9,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Error Handling and Fallbacks",
        "description": "Create a comprehensive error handling system with appropriate fallbacks and user feedback for various error scenarios.",
        "details": "1. Create an ErrorBoundary component:\n   ```tsx\n   // components/ErrorBoundary.tsx\n   'use client';\n   \n   import { Component, ErrorInfo, ReactNode } from 'react';\n   \n   interface Props {\n     children: ReactNode;\n     fallback?: ReactNode;\n   }\n   \n   interface State {\n     hasError: boolean;\n     error: Error | null;\n   }\n   \n   export default class ErrorBoundary extends Component<Props, State> {\n     constructor(props: Props) {\n       super(props);\n       this.state = { hasError: false, error: null };\n     }\n     \n     static getDerivedStateFromError(error: Error): State {\n       return { hasError: true, error };\n     }\n     \n     componentDidCatch(error: Error, errorInfo: ErrorInfo): void {\n       console.error('Error caught by boundary:', error, errorInfo);\n       // Here you could log to an error reporting service\n     }\n     \n     render() {\n       if (this.state.hasError) {\n         if (this.props.fallback) {\n           return this.props.fallback;\n         }\n         \n         return (\n           <div className=\"p-4 bg-red-50 rounded-lg\">\n             <h2 className=\"text-lg font-semibold text-red-800\">Something went wrong</h2>\n             <p className=\"text-red-600 mt-2\">{this.state.error?.message || 'Unknown error'}</p>\n             <button \n               onClick={() => this.setState({ hasError: false, error: null })}\n               className=\"mt-4 px-4 py-2 bg-red-600 text-white rounded-lg\"\n             >\n               Try again\n             </button>\n           </div>\n         );\n       }\n       \n       return this.props.children;\n     }\n   }\n   ```\n2. Create reusable error states for API failures:\n   ```tsx\n   // components/common/ApiErrorState.tsx\n   interface ApiErrorStateProps {\n     message?: string;\n     onRetry?: () => void;\n   }\n   \n   export default function ApiErrorState({ \n     message = '데이터를 불러오는 중 오류가 발생했습니다.',\n     onRetry \n   }: ApiErrorStateProps) {\n     return (\n       <div className=\"p-4 text-center\">\n         <svg className=\"w-12 h-12 mx-auto text-red-500\" fill=\"none\" stroke=\"currentColor\" viewBox=\"0 0 24 24\">\n           <path strokeLinecap=\"round\" strokeLinejoin=\"round\" strokeWidth={2} d=\"M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z\" />\n         </svg>\n         <p className=\"mt-2 text-gray-700\">{message}</p>\n         {onRetry && (\n           <button \n             onClick={onRetry}\n             className=\"mt-4 px-4 py-2 bg-blue-500 text-white rounded-lg\"\n           >\n             다시 시도\n           </button>\n         )}\n       </div>\n     );\n   }\n   ```\n3. Implement global error handling for API requests\n4. Create fallback UI components for each major feature\n5. Add offline detection and handling\n6. Implement retry mechanisms for failed requests",
        "testStrategy": "1. Test error boundary by intentionally causing errors\n2. Verify API error states display correctly\n3. Test offline functionality\n4. Validate retry mechanisms work as expected\n5. Test with various error scenarios (timeout, server error, etc.)\n6. Verify error reporting works correctly",
        "priority": "medium",
        "dependencies": [
          5,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Implement Loading States and Skeletons",
        "description": "Create loading states and skeleton screens for all major components to improve perceived performance and user experience.",
        "details": "1. Create a ShopDetailSkeleton component:\n   ```tsx\n   // components/Shop/ShopDetailSkeleton.tsx\n   export default function ShopDetailSkeleton() {\n     return (\n       <div className=\"space-y-4 animate-pulse\">\n         <div className=\"h-6 bg-gray-200 rounded w-3/4\"></div>\n         \n         <div className=\"h-48 bg-gray-200 rounded-lg\"></div>\n         \n         <div className=\"space-y-2\">\n           {[1, 2, 3, 4, 5].map((i) => (\n             <div key={i} className=\"flex justify-between\">\n               <div className=\"h-4 bg-gray-200 rounded w-1/4\"></div>\n               <div className=\"h-4 bg-gray-200 rounded w-1/3\"></div>\n             </div>\n           ))}\n         </div>\n         \n         <div className=\"border-t pt-4\">\n           <div className=\"h-5 bg-gray-200 rounded w-1/3 mb-2\"></div>\n           <div className=\"h-4 bg-gray-200 rounded w-full\"></div>\n           <div className=\"h-4 bg-gray-200 rounded w-full mt-1\"></div>\n           <div className=\"h-4 bg-gray-200 rounded w-2/3 mt-1\"></div>\n         </div>\n         \n         <div className=\"border-t pt-4\">\n           <div className=\"h-5 bg-gray-200 rounded w-1/3 mb-2\"></div>\n           <div className=\"flex items-center justify-between\">\n             <div className=\"h-4 bg-gray-200 rounded w-1/3\"></div>\n             <div className=\"h-10 bg-gray-200 rounded w-1/4\"></div>\n           </div>\n         </div>\n       </div>\n     );\n   }\n   ```\n2. Create a MapLoadingSkeleton:\n   ```tsx\n   // components/Map/MapLoadingSkeleton.tsx\n   export default function MapLoadingSkeleton() {\n     return (\n       <div className=\"h-screen w-full bg-gray-100 flex items-center justify-center\">\n         <div className=\"text-center\">\n           <div className=\"w-16 h-16 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mx-auto\"></div>\n           <p className=\"mt-4 text-gray-600\">지도를 불러오는 중...</p>\n         </div>\n       </div>\n     );\n   }\n   ```\n3. Create a MarkerLoadingSkeleton\n4. Implement progressive loading for images\n5. Add transition animations between loading and loaded states\n6. Implement staggered loading for lists",
        "testStrategy": "1. Test loading states with artificial delays\n2. Verify skeletons render correctly on different screen sizes\n3. Test transitions between loading and loaded states\n4. Validate loading states are accessible\n5. Test with slow network conditions\n6. Verify loading indicators provide appropriate feedback",
        "priority": "medium",
        "dependencies": [
          3,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Implement Analytics and Monitoring",
        "description": "Add analytics tracking and performance monitoring to gather insights on user behavior and application performance.",
        "details": "1. Set up Google Analytics or similar service:\n   ```tsx\n   // lib/analytics.ts\n   export function trackPageView(url: string) {\n     if (typeof window !== 'undefined' && window.gtag) {\n       window.gtag('config', 'G-XXXXXXXXXX', {\n         page_path: url,\n       });\n     }\n   }\n   \n   export function trackEvent(action: string, category: string, label: string, value?: number) {\n     if (typeof window !== 'undefined' && window.gtag) {\n       window.gtag('event', action, {\n         event_category: category,\n         event_label: label,\n         value: value,\n       });\n     }\n   }\n   ```\n2. Create a custom hook for tracking:\n   ```tsx\n   // hooks/useAnalytics.ts\n   import { usePathname, useSearchParams } from 'next/navigation';\n   import { useEffect } from 'react';\n   import { trackPageView } from '@/lib/analytics';\n   \n   export function usePageViewTracking() {\n     const pathname = usePathname();\n     const searchParams = useSearchParams();\n     \n     useEffect(() => {\n       if (pathname) {\n         const url = searchParams?.size \n           ? `${pathname}?${searchParams.toString()}` \n           : pathname;\n         trackPageView(url);\n       }\n     }, [pathname, searchParams]);\n   }\n   ```\n3. Implement performance monitoring:\n   ```tsx\n   // lib/performance.ts\n   export function trackCoreWebVitals() {\n     if (typeof window !== 'undefined') {\n       // Only in production\n       if (process.env.NODE_ENV === 'production') {\n         import('web-vitals').then(({ getCLS, getFID, getLCP, getFCP, getTTFB }) => {\n           getCLS(sendToAnalytics);\n           getFID(sendToAnalytics);\n           getLCP(sendToAnalytics);\n           getFCP(sendToAnalytics);\n           getTTFB(sendToAnalytics);\n         });\n       }\n     }\n   }\n   \n   function sendToAnalytics({ name, delta, id }: { name: string; delta: number; id: string }) {\n     // Send to Google Analytics or other service\n     if (window.gtag) {\n       window.gtag('event', name, {\n         event_category: 'Web Vitals',\n         event_label: id,\n         value: Math.round(delta),\n         non_interaction: true,\n       });\n     }\n   }\n   ```\n4. Track key user interactions:\n   ```tsx\n   // In components, e.g., when a marker is clicked\n   import { trackEvent } from '@/lib/analytics';\n   \n   const handleMarkerClick = (id: string) => {\n     trackEvent('click', 'marker', id);\n     openSheet(id);\n   };\n   ```\n5. Implement error tracking\n6. Set up custom events for business metrics",
        "testStrategy": "1. Verify analytics events are firing correctly\n2. Test with analytics debugging tools\n3. Validate that performance metrics are being collected\n4. Test in both development and production environments\n5. Verify privacy compliance (GDPR, etc.)\n6. Test with various user flows to ensure all important interactions are tracked",
        "priority": "low",
        "dependencies": [
          10,
          12,
          14
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Implement Final Testing and Deployment",
        "description": "Conduct comprehensive testing across devices and browsers, and set up the deployment pipeline for the application.",
        "details": "1. Set up end-to-end testing with Cypress:\n   ```typescript\n   // cypress/e2e/basic.cy.ts\n   describe('Vacant Shop Map', () => {\n     beforeEach(() => {\n       cy.visit('/');\n     });\n     \n     it('should load the map', () => {\n       cy.get('[data-testid=\"map-container\"]').should('be.visible');\n     });\n     \n     it('should show markers when map loads', () => {\n       cy.get('[data-testid=\"map-marker\"]').should('exist');\n     });\n     \n     it('should open bottom sheet when marker is clicked', () => {\n       cy.get('[data-testid=\"map-marker\"]').first().click();\n       cy.get('[data-testid=\"bottom-sheet\"]').should('be.visible');\n     });\n     \n     it('should close bottom sheet when backdrop is clicked', () => {\n       cy.get('[data-testid=\"map-marker\"]').first().click();\n       cy.get('[data-testid=\"bottom-sheet-backdrop\"]').click();\n       cy.get('[data-testid=\"bottom-sheet\"]').should('not.exist');\n     });\n     \n     it('should filter shops when filters are applied', () => {\n       cy.get('[data-testid=\"filter-button\"]').click();\n       cy.get('[data-testid=\"shop-type-selector\"]').contains('음식점').click();\n       cy.get('[data-testid=\"apply-filters-button\"]').click();\n       // Verify filtered results\n     });\n   });\n   ```\n2. Configure Vercel deployment:\n   ```json\n   // vercel.json\n   {\n     \"version\": 2,\n     \"builds\": [\n       {\n         \"src\": \"package.json\",\n         \"use\": \"@vercel/next\"\n       }\n     ],\n     \"routes\": [\n       {\n         \"src\": \"/(.*)\",\n         \"dest\": \"/\"\n       }\n     ],\n     \"env\": {\n       \"NEXT_PUBLIC_MAP_API_KEY\": \"@map_api_key\",\n       \"NEXT_PUBLIC_API_URL\": \"@api_url\"\n     }\n   }\n   ```\n3. Set up CI/CD pipeline\n4. Implement browser and device testing\n5. Conduct performance testing\n6. Set up monitoring and alerting\n7. Prepare documentation for maintenance",
        "testStrategy": "1. Run end-to-end tests on multiple browsers\n2. Test on actual mobile devices (iOS and Android)\n3. Conduct performance testing with Lighthouse\n4. Verify all features work in production environment\n5. Test deployment rollback procedures\n6. Validate monitoring and alerting systems",
        "priority": "high",
        "dependencies": [
          3,
          6,
          8,
          10,
          12,
          14,
          15,
          16
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-22T05:08:42.681Z",
      "updated": "2025-07-22T09:13:40.656Z",
      "description": "Tasks for master context"
    }
  }
}